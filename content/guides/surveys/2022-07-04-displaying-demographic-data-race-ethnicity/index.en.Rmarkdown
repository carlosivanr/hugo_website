---
title: 'Displaying Race & Ethnicity Data'
author: Carlos Rodriguez
date: '`r Sys.Date()`'
slug: displaying-demographic-data-race-ethnicity
categories: []
tags: []
subtitle: ''
summary: ''
authors: []
lastmod: '`r Sys.time()`'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---


```{r load libraries, message=FALSE, warning=FALSE, echo=FALSE}
library(tidyverse)
library(gtsummary)
library(bstfun)
library(kableExtra)
```


```{r load data, echo=FALSE}
load("C:/Users/rodrica2/OneDrive/Web Site/hugo_website/content/guides/surveys/2022-07-04-survey-data/sample_data.Rdata")
data <- sample_n(data, 150)
```


It is not uncommon for surveys to collect race and ethnicity data from participants. In some cases, these questions can allow participants to select multiple responses if they would like to endorse more than one race or ethnicity. In this post, I will cover how to create a table and bar chart to display race and ethnicity data.


### Packages
```{r}
library(tidyverse)
library(gtsummary)
library(bstfun)
```

### Tables
For displaying race and ethnicity data in a table, I use a combination of the [gt_summary](https://www.danieldsjoberg.com/gtsummary/) and [btsfun](https://www.danieldsjoberg.com/bstfun/index.html) packages. In order to use these packages, my first step is to create a data frame in a way that looks like the table below. In this preparation, each row represent a participant and each column represent a distinct race or ethnic category coded as a binary variable where 1 indicates that the participant selected that category. Each participant can then endorse multiple categories.
```{r, echo = FALSE}
race_vars <- names(data %>% select(starts_with("demographic") & 
                              !ends_with(".factor") & 
                              contains("race") &
                              !contains("other")))
race_names <- as.character(data %>% 
                             select(all_of(race_vars)) %>% 
                             map_df(., ~attr(.x, "label"))
                           )
```
```{r table1, echo = FALSE}
kable(head(data %>% select(all_of(race_vars)) %>%
             mutate_at(all_of(race_vars), ~ as.numeric(.)) %>% 
             rename_at(all_of(race_vars), ~ race_names) %>%
             arrange(desc(`Hispanic or Latino`))), caption = "The aim to create a data frame like this.")
```

1. My example data are already formatted in such a way, so my first step will be to create a character vector of the columns names that contain the responses of interest. In my example data, these columns start with "demographic" and contain "race." However, I want to exclude some of the columns that end with a ".factor" and contain the string "other." I then wrap this selection with the `names()` function to assign the column names to a character vector. This vector will be used as an argument in a subsequent step and it comes in handy when using the `select()` verb to subset the data.
```{r}
race_vars <- names(data %>% select(starts_with("demographic") & 
                              !ends_with(".factor") & 
                              contains("race") &
                              !contains("other")))
race_vars
```

2. Next, I begin piping the data to `select()` using the vector of variables created in Step 1 and then through the `tbl_summary()` function. Then, we can pipe the output table to the `add_variable_grouping()` function to indent all of the columns under a grouping variable, "Race/Ethnicity", and once again uses our vector of variables from Step 1. The example data displayed here are labelled, so even though the columns are named something like "demographic_4_race___*", the `tbl_summary()` function will display the corresponding labels automatically.
```{r table of race/ethnicity, eval=FALSE}
data %>% 
  select(all_of(race_vars)) %>%
  tbl_summary() %>%
  add_variable_grouping("Race/Ethnicity" = race_vars)
```

```{r table2, echo=FALSE}
# Create a table summary object
tab2 <- data %>% 
  select(all_of(race_vars)) %>%
  tbl_summary() %>%
  add_variable_grouping("Race/Ethnicity" = race_vars)

# Remove the asterisks in the table summary object
tab2[["table_styling"]][["header"]][["label"]][5] <- str_sub(
  tab2[["table_styling"]][["header"]][["label"]][5], 3, -3)

tab2[["table_styling"]][["header"]][["label"]][6] <- str_sub(
  tab2[["table_styling"]][["header"]][["label"]][6], 3, -3)

# Display the table summary object as_kable to add the caption
as_kable(tab2, caption = "Percent of participants endorsing a category.")
```

<br>

### Bar Charts
One way to display this type of information is in a bar char that displays the percent of participants that endorse any given category. Unlike `tbl_summary()` where the columns labels are automatically displayed, `ggplot()` requires manually setting labels if the column names aren't presentable.

1. As a result, my first step is to get the labels of the columns. I show two different approaches in getting labels. The first is through a for-loop and the second is through the `map_df()` function in the purrr package. If the data are not labelled, then creating a vector of labels can still be helpful if you want to preserve your column names for what ever reason and simply change the labels on the plot.
```{r , get the labels}
# Use the vector of race_vars to get the column labels
race_names <- ""
for (i in 1:length(race_vars)){
  race_names[i] <- attr(data[, race_vars[i]], "label")
}

# Alternative form using purrr
race_names <- as.character(data %>% 
                             select(all_of(race_vars)) %>% 
                             map_df(., ~attr(.x, "label"))
                           )

race_names
```


2. My next step is to use the race_vars and race_names in a chain of commands that selects the columns, converts them numeric, renames them, converts to long format, and then factors the categories The reason for converting numeric here is because the labelled columns some times do not play well with tidyverse functions. Converting to numeric facilitates the use of the `rename_at()` verb with the vector of variable names. The output shows an example of what the data look like at this step.
```{r }
plot_data <- data %>% 
  select(all_of(race_vars)) %>%
  mutate_at(all_of(race_vars), ~ as.numeric(.)) %>% 
  rename_at(all_of(race_vars), ~ race_names) %>%
  pivot_longer(all_of(race_names),
               names_to = "Category",
               values_to = "Endorsed") %>%
  mutate(Category = factor(Category, levels = race_names))

plot_data
```

```{r, echo=FALSE, eval = FALSE}
kable(head(data %>% 
  select(all_of(race_vars)) %>%
  mutate_at(all_of(race_vars), ~ as.numeric(.)) %>% 
  rename_at(all_of(race_vars), ~ race_names) %>%
  pivot_longer(all_of(race_names),
               names_to = "Category",
               values_to = "Endorsed") %>%
  mutate(Category = factor(Category, levels = race_names))))
```

3. Building from there, the next step is to `group_by()` category, `summarise()` the sum of Endorsed as Frequency, and then calculate the proportion of participants that endorse a particular category with the `mutate()` verb.

```{r}
plot_data <- plot_data %>%
  group_by(Category) %>%
  summarise(Frequency = sum(Endorsed, na.rm = TRUE)) %>%
  mutate(Proportion = Frequency/nrow(data))

plot_data
```

4. The other option is to use `reorder()` within the ggplot call to order the responses by proportion. Both options are shown here, but the `reorder()` function is what is displayed as it happens later in the chain of commands. After setting the levels, I group by category and `summarise()` the sum of participants that endorsed a given category in a new column called "Frequency". Next, I create a new column called "Proportion" that is "Frequency" over the number of participants given by the number of rows in the data frame, not responses.

3. Finally, the remaining data frame is ready to be piped into `ggplot()` where I will subsequently flip the coordinates to display horizontal bars and change the x label to "Category" with the `xlab()` layer. The color and fill arguments inside `geom_col()`, `theme_minimal()`, and the axis.line argument of the `theme()`functions add the finishing touches to this plot. 



```{r , plot of race/ethnicity}
data %>% 
  select(all_of(race_vars)) %>%
  mutate_at(all_of(race_vars), ~ as.numeric(.)) %>% 
  rename_at(all_of(race_vars), ~ race_names) %>%
  pivot_longer(all_of(race_names),
               names_to = "Category",
               values_to = "Endorsed") %>%
  mutate(Category = factor(Category, levels = race_names)) %>%
  group_by(Category) %>%
  summarise(Frequency = sum(Endorsed, na.rm = TRUE)) %>%
  mutate(Proportion = Frequency/nrow(data)) %>%
  ggplot(aes(x = reorder(Category, Proportion), y = Proportion)) +
  geom_col(color = "#1565c0", fill = "#1565c0") +
  coord_flip() +
  theme_minimal() +
  xlab("Category") +
  theme(axis.line = element_line(color = "grey70"))
```